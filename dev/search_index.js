var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#CooperativeTasks.Command","page":"API","title":"CooperativeTasks.Command","text":"Execute ret = f() on a task, optionally executing continuation(ret) from the task the message has been sent from.\n\nFirst, the command is registered on a source task with a corresponding UUID. Then, as part of a message, it is sent to the destination task for execution, which will send back the value associated with this UUID if any continuation has been provided. If so, when the source task next collects new messages, it will run continuation with the returned value.\n\nstruct Command\n\nf::Any\nargs::Any\nkwargs::Any\ncontinuation::Any\n\n\n\n\n\n","category":"type"},{"location":"api/#CooperativeTasks.Future","page":"API","title":"CooperativeTasks.Future","text":"Operation waiting on another task to produce and return a value.\n\nThe value is accessible using fetch and tryfetch, with a timeout that may be set as a parameter.\n\nmutable struct Future\n\nuuid::Base.UUID\nvalue::Ref{Any}\nfrom::Task\nto::Task\n\n\n\n\n\n","category":"type"},{"location":"api/#CooperativeTasks.LoopExecution","page":"API","title":"CooperativeTasks.LoopExecution","text":"Execute a function repeatedly until a shutdown is scheduled with schedule_shutdown.\n\nIf period is greater than a millisecond, every iteration may trigger a sleep for the remaining period time after executing the main function. Simple heuristics are used to prevent sleeping when there were recent interactions with other tasks, to avoid suffering from large communication delays.\n\nAt every iteration, task messages will be checked and allow (among other things) to compute/return results to other tasks (see Future), and to cancel the task. This mode of execution is preferred over manual loops precisely for the ability to satisfy task duties as required in the context of this library.\n\nstruct LoopExecution\n\nperiod::Union{Nothing, Float64}\nstate::CooperativeTasks.ExecutionState\nshutdown::Bool: Whether to call shutdown() on this task after the loop finishes executing.\nCan be useful in contexts where SingleExecution and LoopExecution are mixed together, to avoid shutting down multiple times.\n\n\n\n\n\n","category":"type"},{"location":"api/#CooperativeTasks.Message","page":"API","title":"CooperativeTasks.Message","text":"Message sent by a task with an optional payload, identified by a UUID.\n\nIf critical is set to true, it will be processed before all non-critical messages.\n\nstruct Message{T}\n\nfrom::Task\nuuid::Base.UUID\npayload::Any\ncritical::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/#CooperativeTasks.SingleExecution","page":"API","title":"CooperativeTasks.SingleExecution","text":"Execute a function once, then return.\n\nstruct SingleExecution\n\nshutdown::Bool: Whether to call shutdown() on this task after the loop finishes executing.\nCan be useful in contexts where SingleExecution and LoopExecution are mixed together, to avoid shutting down multiple times.\n\n\n\n\n\n","category":"type"},{"location":"api/#CooperativeTasks.SpawnOptions","page":"API","title":"CooperativeTasks.SpawnOptions","text":"Options for spawning tasks with spawn.\n\nstruct SpawnOptions\n\nexecution_mode::Union{SingleExecution, LoopExecution}: Specifies how the task should be run, via a SingleExecution or LoopExecution structure.\n\nstart_threadid::Union{Nothing, Int64}: Optional 1-based thread ID to start the task on.\nIf task migration is disabled, then the task will execute on this thread during its entire lifespan. If set to nothing (default), then the starting thread is the same as the thread launching the task.\nwarning: Warning\nIf task migration is disabled, and no start thread ID has been set, the task will run similarly to an @async-spawned task and execution will never occur in parallel between the spawning task and the spawned task.\n\ndisallow_task_migration::Bool: Disallow tasks to migrate between Julia threads (false by default).\nWhen set to false, this corresponds to the behavior of @async, and when set to true, to the behavior of Threads.@spawn.\nPreventing task migration enables the use of Threads.threadid() as an index from the spawned tasks. For example, consider the following pattern:\nconst results = [Int[] for i in 1:Threads.nthreads()]\n\n# ...\n# Spawn a bunch of tasks.\n# ...\n# Execute code like the following from these tasks:\npush!(results[Threads.threadid()], rand())\nThis pattern requires Threads.threadid() to be constant over the entire lifespan of the tasks, which requires task migration to be disabled.\nDisabling task migration can also be useful when e.g. C libraries rely on functions to be executed in the same thread in which some library-defined context has been created, as can be the case for graphics API such as Vulkan or OpenGL.\n\n\n\n\n\n","category":"type"},{"location":"api/#CooperativeTasks.TaskException","page":"API","title":"CooperativeTasks.TaskException","text":"Emitted when a task has failed, for a reason described with its StatusCode and an optional message.\n\nstruct TaskException <: Exception\n\nmsg::String\ncode::CooperativeTasks.StatusCode\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.fetch-Tuple{Union{Future, Result{Future}}}","page":"API","title":"Base.fetch","text":"Fetch the value of the future, waiting at most timeout seconds if the value is not available yet.\n\nIf sleep_time is nonzero, sleep(sleep_time) will be called while waiting.\n\nIf an error occurs, or timeout seconds have passed without result, an exception will be thrown.\n\nfetch(\n    future::Union{Future, Result{Future}};\n    timeout,\n    sleep_time\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"api/#CooperativeTasks.cancel-Tuple{Task}","page":"API","title":"CooperativeTasks.cancel","text":"Request the task to cancel its execution.\n\ncancel(task::Task) -> Result{Future, TaskException}\n\n\n\n\n\n\n","category":"method"},{"location":"api/#CooperativeTasks.istasksuccessful-Tuple{Task}","page":"API","title":"CooperativeTasks.istasksuccessful","text":"Check whether the task has successfully terminated execution.\n\nBy default, an error will be logged if an exception was found; set log = false to prevent that.\n\nistasksuccessful(task::Task; log) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"api/#CooperativeTasks.schedule_shutdown-Tuple{}","page":"API","title":"CooperativeTasks.schedule_shutdown","text":"Signal the current task to shut down.\n\nTo check if a task received such a signal, use shutdown_scheduled.\n\nschedule_shutdown() -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"api/#CooperativeTasks.shutdown-Tuple{Task}","page":"API","title":"CooperativeTasks.shutdown","text":"Shut down a task by cancelling it if it has not completed.\n\nSee cancel.\n\nshutdown(task::Task) -> CooperativeTasks.Condition\n\n\n\n\n\n\n","category":"method"},{"location":"api/#CooperativeTasks.shutdown_owned_tasks-Tuple{}","page":"API","title":"CooperativeTasks.shutdown_owned_tasks","text":"Shutdown all children of the current task. Returns a Condition which can be waited on.\n\nshutdown_owned_tasks() -> CooperativeTasks.Condition\n\n\n\n\n\n\n","category":"method"},{"location":"api/#CooperativeTasks.shutdown_scheduled-Tuple{}","page":"API","title":"CooperativeTasks.shutdown_scheduled","text":"Return whether the current task is scheduled for shutdown with schedule_shutdown.\n\nIf this function returns true, the task is responsible for finishing any pending activity and shutting itself down.\n\nshutdown_scheduled() -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"api/#CooperativeTasks.spawn-Tuple{Any, SpawnOptions}","page":"API","title":"CooperativeTasks.spawn","text":"Spawn a new task executing the function f.\n\nnote: Note\nDepending on the execution_mode parameter of the provided SpawnOptions, f() may be executed multiple times.\n\nspawn(f, options::SpawnOptions) -> Task\n\n\n\n\n\n\n","category":"method"},{"location":"api/#CooperativeTasks.tryfetch-Tuple{Union{Future, Result{Future}}}","page":"API","title":"CooperativeTasks.tryfetch","text":"Fetch the value of the future, waiting at most timeout seconds if the value is not available yet.\n\nIf sleep_time is nonzero, sleep(sleep_time) will be called while waiting.\n\nIf an error occurs, or timeout seconds have passed without result, an exception will be returned.\n\nThis performs the same as fetch, but does not throw and wraps the returned value or exception into a Result.\n\ntryfetch(\n    future::Union{Future, Result{Future}};\n    timeout,\n    sleep_time\n) -> Result{Any, Union{ExecutionError, PropagatedTaskException, TaskException}}\n\n\n\n\n\n\n","category":"method"},{"location":"api/#CooperativeTasks.trysend-Tuple{Task, Message}","page":"API","title":"CooperativeTasks.trysend","text":"Send a message m to task, unless the task is dead.\n\ntrysend(\n    task::Task,\n    m::Message\n) -> Result{Future, TaskException}\n\n\n\n\n\n\n","category":"method"},{"location":"api/#CooperativeTasks.@spawn","page":"API","title":"CooperativeTasks.@spawn","text":"@spawn [options] $ex\n@spawn begin ... end\n@spawn :single begin ... end\n@spawn :looped begin ... end\n\nConvenience macro to spawn a task via spawn, defining a closure over ex as the function to be executed by the task.\n\n\n\n\n\n","category":"macro"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Multi-threaded-application-architecture","page":"Examples","title":"Multi-threaded application architecture","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"An example use case that motivated the creation of this library is that of an application architecture that separates the rendering thread from the application thread.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The rendering thread submits work to the GPU to display visual elements, while the application thread processes user inputs and runs the application logic. The rendering thread may operate with a frequency somewhere around 60 Hz, while the application thread may operate faster or slower depending on reactivity requirements.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Both the rendering thread and application thread would use tasks spawned on different threads, with task migration turned off to prevent concurrency errors, particularly for certain GPU APIs which may have strong requirements in this regard for a number of API calls. For each frame, the rendering thread would ask the application thread to return the list of all visual elements to be rendered. When the user exits the application, the application thread would ask the rendering thread to shut down gracefully before shutting down itself, resulting in a smooth shutdown procedure.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For the purpose of testing, the application may be launched asynchronously, where the main thread spawns the application thread which in turn spawns the rendering thread. The main thread may schedule the execution of state-modifying functions by the application thread, before waiting for the application to finalize modifications and eventually perform a test on the application state. The main thread may monitor application and rendering tasks while waiting for processing to be done, before detaching and running its tests.","category":"page"},{"location":"#CooperativeTasks","page":"Home","title":"CooperativeTasks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CooperativeTasks facilitates working with long-running tasks by adding mechanisms for task spawning, code execution, monitoring, and error reporting.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package defines a new @spawn macro, with several options to control task execution. For example, a task may be started on a specific thread, with task migration disabled to keep the task running on that specific thread.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Most of the functionality defined in this package relies on inter-task communication using channels, with a protocol based on message passing.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A core paradigm behind this functionality is the handling of concurrency via sequential operations. While certain procedures use parallel execution for speed, there are environments that are inherently concurrent but without the need to rely on parallelism. Databases are a good example of this; if one has a database exposed over a network, and multiple applications need to perform read and write operations on the contents of this database concurrently, the best solution is to asynchronously queue these requests and wait for a database server to process them. It is a lot easier to request a unit to carry out a series of operations than it is to concurrently execute them safely. This shifts the burden of concurrency safety concerns to the queuing of requests instead of their execution, which is significantly easier.","category":"page"}]
}
